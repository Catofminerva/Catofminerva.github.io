<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Ali's Web Chat</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    /* 90s desktop vibe */
    body { margin:0; background:#c0c0c0; font:13px Arial, Helvetica, sans-serif; color:#000; }
    .window { width:900px; max-width:100%; margin:20px auto; border:1px solid #808080; background:#f0f0f0; }
    .statusbar { background:#eaeaea; border-top:1px solid #c0c0c0; padding:4px 8px; font-size:12px; color:#333; display:flex; justify-content:space-between; }
    .layout { display:grid; grid-template-columns: 1fr 220px; gap:0; }
    .left { border-right:1px solid #bdbdbd; background:#fff; }
    .right { background:#fff; }
    #log { height:420px; overflow-y:auto; padding:8px; font:13px "Courier New", Courier, monospace; white-space:pre-wrap; word-break:break-word; }
    .sys { color:#666; }
    .inputbar { padding:6px; background:#f5f5f5; border-top:1px solid #bdbdbd; }
.row { display:flex; gap:6px; margin-bottom:6px; align-items: center; }
    input[type="text"] { flex:1; padding:6px; border:1px solid #999; background:#fff; color:#000; font:13px Arial, Helvetica, sans-serif; }
    input[name="nick"] { flex:0 0 180px; }
    button { padding:5px 10px; border:1px solid #666; background:#e6e6e6; cursor:pointer; }
    button:active { background:#d9d9d9; }
    .toolbar { display:flex; gap:6px; align-items:center; font-size:12px; }
    select { border:1px solid #999; background:#fff; padding:2px 4px; font-size:12px; }
    #roster { height:420px; overflow-y:auto; padding:8px; font:12px Arial, Helvetica, sans-serif; }
    #roster .user { padding:2px 0; border-bottom:1px dotted #ddd; }

    /* Menus */
    .menubar { position: relative; background:#e0e0e0; border-bottom:1px solid #a0a0a0; padding:4px 6px; }
    .menu-btn { border:1px solid #9a9a9a; background:#e6e6e6; padding:2px 8px; font-size:12px; margin-right:6px; cursor:pointer; }
    .menu-btn:active { background:#d9d9d9; }
    .dropdown { position:absolute; top:26px; left:0; display:none; background:#fff; border:1px solid #9a9a9a; min-width:210px; z-index:10; box-shadow: 0 1px 0 #ccc inset; }
    .dropdown a { display:block; padding:6px 10px; font-size:12px; color:#000; cursor:pointer; }
    .dropdown a:hover { background:#e8e8e8; }

    /* Toggles */
    #log.hide-ts .ts { display:none; }
    #log .hilite { background:#fff59d; }
    .hidden { display:none !important; }

.edit{
  flex: 1;
  height: 42px;          /* fixed default height (tweak to taste) */
  max-height: 120px;     /* never grow beyond this */
  overflow-y: auto;      /* scroll inside instead of expanding */
  border: 1px solid #999;
  background: #fff;
  padding: 6px;
  white-space: pre-wrap;
  word-break: break-word;
  outline: none;
  box-sizing: border-box;
}
/* placeholder */
.edit:empty:before{ content: attr(data-ph); color:#777; }

.topicbar { background:#f3f3f3; border-bottom:1px solid #d0d0d0; padding:4px 8px; font-size:12px; }
.whisper { color: purple; font-style: italic; }
.emote { font-style: italic; }
#typing { color:#555; margin-left:8px; }

    .tips{ font-size:11px; color:#444; margin-top:4px; line-height:1.35; }
.tips a{ color:#000; text-decoration:underline; cursor:pointer; }
.tips code{ background:#f2f2f2; border:1px solid #ddd; padding:0 2px; }

    
  </style>
</head>
<body>
  <div class="window">
    <!-- Menubar with ONE set of dropdowns -->
    <div class="menubar" id="menubar">
      <button class="menu-btn" data-menu="file">File ▾</button>
      <button class="menu-btn" data-menu="edit">Edit ▾</button>
      <button class="menu-btn" data-menu="view">View ▾</button>
      <button class="menu-btn" data-menu="im">IM ▾</button>
      <button class="menu-btn" data-menu="help">Help ▾</button>

      <div class="dropdown" id="menu-file">
        <a data-action="save-log">Save Log…</a>
        <a data-action="print">Print…</a>
        <a data-action="clear-log">Clear Log</a>
        <a data-action="join-room">Join Room…</a>
      </div>
      <div class="dropdown" id="menu-edit">
        <a data-action="copy-log">Copy Log to Clipboard</a>
        <a data-action="find">Find…</a>
        <a data-action="select-all">Select All</a>
      </div>
      <div class="dropdown" id="menu-view">
        <a data-action="zoom-in">Zoom In</a>
        <a data-action="zoom-out">Zoom Out</a>
        <a data-action="toggle-timestamps">Show/Hide Timestamps</a>
        <a data-action="toggle-roster">Show/Hide Roster</a>
      </div>
      <div class="dropdown" id="menu-im">
        <a data-action="toggle-beep">Beep on New Message</a>
        <a data-action="set-topic">Set Topic…</a>
      </div>
      <div class="dropdown" id="menu-help">
        <a data-action="help">Formatting Help…</a>
        <a data-action="about">About…</a>
      </div>
    </div>
     
    <div class="topicbar">Topic: <span id="topicText">(none)</span></div>

    
    <div class="layout">
<div class="left">
  <div id="log" aria-live="polite"></div>

  <div class="inputbar">
    <div class="row">
      <label for="nick" style="align-self:center;">Nick:</label>
      <input type="text" id="nick" name="nick" maxlength="24" placeholder="Your name">
      <button id="setNick">Set</button>
    </div>

    <div class="row toolbar">
      <button id="bBtn"><b>B</b></button>
      <button id="iBtn"><i>I</i></button>
      <button id="uBtn"><u>U</u></button>
      <label>Color:
        <select id="colorSel">
          <option value="">—</option>
          <option>black</option><option>red</option><option>blue</option>
          <option>green</option><option>maroon</option><option>purple</option>
          <option>teal</option><option>navy</option>
        </select>
      </label>
      <label>Font:
        <select id="fontSel">
          <option value="">—</option>
          <option>Arial</option><option>Times New Roman</option>
          <option>Courier New</option><option>Verdana</option>
        </select>
      </label>
      <label>Size:
        <select id="sizeSel">
          <option value="">—</option>
          <option>10</option><option>12</option><option>14</option>
          <option>16</option><option>18</option>
        </select>
      </label>
    </div>

    <div class="row">
      <div id="msgEdit" class="edit" contenteditable="true" data-ph="Type message"></div>
      <button id="send">Send</button>
    </div>

    <!-- Tips live INSIDE .inputbar, under the Send row -->
    
  </div> <!-- /.inputbar -->
</div> <!-- /.left -->


      
      <div class="right">
        <div class="menubar">People in Room</div>
        <div id="roster"></div>
      </div>
    </div>

  <div class="tips" id="tips">
  <strong>Tips:</strong>
  Enter sends, Shift+Enter = newline.
  Type <code>/me waves</code> for an emote.
  Right-click a name to whisper/ignore.
  Double-click the topic to edit, or IM → Set Topic….
  Pick Color/Font with no selection to set your default style.
  View → Show/Hide Timestamps, File → Join Room.
  <a href="#" id="hideTips">Hide</a> · <a href="#" id="moreHelp">More</a>
</div>
    
<div class="statusbar">
  <div id="status">Connecting…</div>
  <div id="typing"></div>
  <div id="roomLabel"></div>
</div>

  </div>
  
  <div id="ctx" style="position:absolute;display:none;background:#fff;border:1px solid #9a9a9a;z-index:20;min-width:160px;">
  <a href="#" id="ctx-whisper" style="display:block;padding:6px 10px;">Whisper…</a>
  <a href="#" id="ctx-ignore"  style="display:block;padding:6px 10px;">Ignore/Unignore</a>
</div>
  
  <script>
    // ===== Config =====
    const WORKER_HOST = "chat.asalmaadeed.workers.dev"; // change if your worker hostname differs
    const ROOM = new URL(location.href).searchParams.get("room") || "lobby";
    document.getElementById("roomLabel").textContent = "Room: " + ROOM;

    // ===== State =====
    const NICK_KEY = "aolchat_nick";
    let nick = localStorage.getItem(NICK_KEY) || ("User" + Math.floor(Math.random()*1000));
    const $ = id => document.getElementById(id);
    $("nick").value = nick;

    let ws;

    let beepOn = true;

  let typingTimer = null;
let ignored = new Set(JSON.parse(localStorage.getItem("ignored") || "[]"));
const saveIgnored = () => localStorage.setItem("ignored", JSON.stringify([...ignored]));

    // ===== Connect =====
    function wsUrl(){ return "wss://" + WORKER_HOST + "/room/" + encodeURIComponent(ROOM); }
    function setStatus(s){ $("status").textContent = s; }
    function connect(){
      ws = new WebSocket(wsUrl());
      setStatus("Connecting");
      ws.onopen = () => { setStatus("Online"); send({ type:"hello", username:nick }); };
      ws.onclose = () => { setStatus("Disconnected"); setTimeout(connect, 1200); };
      ws.onerror = () => { setStatus("Error"); try { ws.close(); } catch {} };
      ws.onmessage = onMessage;
    }

    // ===== UI actions =====
    $("setNick").onclick = () => {
      const v = $("nick").value.trim();
      if (!v) return;
      nick = v.slice(0, 24);
      localStorage.setItem(NICK_KEY, nick);
      send({ type:"nick", username:nick });
      sysLine("* nick set to " + nick);
    };

    $("send").onclick = sendChat;



// Keep these at the top near your editor setup
const editor = document.getElementById("msgEdit");
let defaultColor = "";
let defaultFont  = "";
let defaultSize  = ""; // optional

// Bold / italic / underline: still selection-based
document.getElementById("bBtn").onclick = () => document.execCommand("bold");
document.getElementById("iBtn").onclick = () => document.execCommand("italic");
document.getElementById("uBtn").onclick = () => document.execCommand("underline");

// Helper: is there a selection *inside* the editor?
function hasEditorSelection() {
  const sel = document.getSelection();
  return sel && !sel.isCollapsed && editor.contains(sel.anchorNode);
}

// Color: selection → color that selection; no selection → set default for whole message
document.getElementById("colorSel").onchange = (e) => {
  const v = e.target.value; if (v === null) return;
  if (hasEditorSelection()) {
    if (v) document.execCommand("foreColor", false, v);
  } else {
    defaultColor = v || "";
    editor.style.color = defaultColor || "";   // live preview while typing
  }
};

// Font: selection → font for selection; no selection → set default for whole message
document.getElementById("fontSel").onchange = (e) => {
  const v = e.target.value; if (v === null) return;
  if (hasEditorSelection()) {
    if (v) document.execCommand("fontName", false, v);
  } else {
    defaultFont = v || "";
    editor.style.fontFamily = defaultFont || "";  // live preview
  }
};

// Size (optional): same pattern. Remove if you want size to stay selection-only.
document.getElementById("sizeSel").onchange = (e) => {
  const v = e.target.value; if (v === null) return;
  if (hasEditorSelection()) {
    if (v) document.execCommand("fontSize", false, sizeToLegacy(parseInt(v,10)));
  } else {
    defaultSize = v || "";
    editor.style.fontSize = defaultSize ? `${parseInt(defaultSize,10)}px` : "";
  }
};


// Enter sends; Shift+Enter makes a newline
editor.addEventListener("keydown", (e) => {
  if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); sendChat(); }
});

// Paste as plain text to avoid weird HTML
editor.addEventListener("paste", (e) => {
  e.preventDefault();
  const t = (e.clipboardData || window.clipboardData).getData("text/plain");
  document.execCommand("insertText", false, t);
});

// Map px → legacy fontSize (1..7) used by execCommand
function sizeToLegacy(n){
  return (n<=10?2:n<=12?3:n<=14?4:n<=16?5:n<=18?6:7);
}

function sendTyping() {
  try { ws && ws.readyState === 1 && ws.send(JSON.stringify({ type:"typing", username:nick })); } catch {}
}
let typingThrottle = false;
editor.addEventListener("input", () => {
  if (!typingThrottle) { typingThrottle = true; sendTyping(); setTimeout(()=>typingThrottle=false, 1500); }
});

   

function sendChat(){
  const html = editor.innerHTML.trim();
  const base = htmlToBB(html).trim();
  if (!base || !ws || ws.readyState !== 1) return;

  // emote: /me waves
  if (base.startsWith("/me ")) {
    send({ type:"emote", username:nick, text: base.slice(4) });
    editor.innerHTML = "";
    if (defaultColor) editor.style.color = defaultColor;
    if (defaultFont)  editor.style.fontFamily = defaultFont;
    if (defaultSize)  editor.style.fontSize = `${parseInt(defaultSize,10)}px`;
    return;
  }

  let bb = base;
  if (defaultFont)  bb = `[font=${defaultFont}]${bb}[/font]`;
  if (defaultSize)  bb = `[size=${parseInt(defaultSize,10)}]${bb}[/size]`;
  if (defaultColor) bb = `[color=${defaultColor}]${bb}[/color]`;
  send({ type:"chat", username:nick, text: bb });
  editor.innerHTML = "";
  if (defaultColor) editor.style.color = defaultColor;
  if (defaultFont)  editor.style.fontFamily = defaultFont;
  if (defaultSize)  editor.style.fontSize = `${parseInt(defaultSize,10)}px`;
}



// Safe HTML → BBCode (b/i/u + <font color|face|size> + <br>/<div>)
function htmlToBB(html){
  const container = document.createElement("div");
  container.innerHTML = html;

  const pxFromLegacy = {1:10,2:10,3:12,4:14,5:16,6:18,7:20};

  const walk = (node) => {
    if (node.nodeType === Node.TEXT_NODE) return node.nodeValue;
    if (node.nodeType !== Node.ELEMENT_NODE) return "";

    const tag = node.tagName.toLowerCase();
    let open = "", close = "";

    if (tag === "b" || tag === "strong") { open="[b]"; close="[/b]"; }
    else if (tag === "i" || tag === "em") { open="[i]"; close="[/i]"; }
    else if (tag === "u") { open="[u]"; close="[/u]"; }
    else if (tag === "br") { return "\n"; }
    else if (tag === "div" || tag === "p") {
      // treat block as content + newline
      const inner = Array.from(node.childNodes).map(walk).join("");
      return inner + "\n";
    }
    else if (tag === "font") {
      const color = node.getAttribute("color");
      const face  = node.getAttribute("face");
      const size  = node.getAttribute("size");
      if (color) { open += `[color=${color}]`; close = `[/color]` + close; }
      if (face)  { open += `[font=${face}]`;   close = `[/font]` + close;  }
      if (size)  { const px = pxFromLegacy[size] || 12;
                   open += `[size=${px}]`;      close = `[/size]` + close;  }
    }
    else if (tag === "span") {
      const style = node.getAttribute("style") || "";
      const mColor = style.match(/color\s*:\s*([^;]+)/i);
      const mFace  = style.match(/font-family\s*:\s*([^;]+)/i);
      const mSize  = style.match(/font-size\s*:\s*(\d+)/i);
      if (mColor) { open += `[color=${mColor[1]}]`; close = `[/color]` + close; }
      if (mFace)  { open += `[font=${mFace[1]}]`;  close = `[/font]` + close;  }
      if (mSize)  { open += `[size=${parseInt(mSize[1],10)}]`; close = `[/size]` + close; }
    }
    const inner = Array.from(node.childNodes).map(walk).join("");
    return open + inner + close;
  };

  // Join top-level nodes and trim trailing newlines added by div/p handling
  return Array.from(container.childNodes).map(walk).join("").replace(/\n+$/,"");
}
    
    function send(obj){ try { ws.send(JSON.stringify(obj)); } catch {} }

    // ===== Render =====
    function escapeHtml(s){
      return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
    }
    function bbcodeToHtml(src){
      let s = escapeHtml(src);
      s = s.replace(/\[b\]([\s\S]*?)\[\/b\]/gi, "<strong>$1</strong>");
      s = s.replace(/\[i\]([\s\S]*?)\[\/i\]/gi, "<em>$1</em>");
      s = s.replace(/\[u\]([\s\S]*?)\[\/u\]/gi, "<u>$1</u>");
      s = s.replace(/\[color=(#[0-9a-fA-F]{3,6}|[a-zA-Z]{1,15})\]([\s\S]*?)\[\/color\]/gi,
        (m, color, inner) => `<span style="color:${color}">${inner}</span>`);
      s = s.replace(/\[size=(\d{1,2})\]([\s\S]*?)\[\/size\]/gi,
        (m, n, inner) => `<span style="font-size:${Math.max(8, Math.min(24, parseInt(n,10)))}px">${inner}</span>`);
      s = s.replace(/\[font=([A-Za-z0-9 ,'-]{1,30})\]([\s\S]*?)\[\/font\]/gi,
        (m, name, inner) => {
          const allowed = ["Arial","Times New Roman","Courier New","Verdana"];
          const pick = allowed.find(f => f.toLowerCase() === name.toLowerCase());
          return pick ? `<span style="font-family:'${pick}'">${inner}</span>` : inner;
        });
      return s;
    }
    function sysLine(t){
      const div = document.createElement("div");
      div.className = "sys"; div.textContent = t;
      const log = $("log"); log.appendChild(div); log.scrollTop = log.scrollHeight;
    }
    function renderMessage(m){
  const time = m.time ? new Date(m.time).toLocaleTimeString() : "";
  const log = document.getElementById("log");
  const div = document.createElement("div");
  if (m._class) div.className = m._class;

  const ts = document.createElement("span"); ts.className = "ts"; ts.textContent = "[" + time + "] ";

  if (m._class === "emote") {
    const msg = document.createElement("span");
    msg.innerHTML = "* " + (m.username || "Anon") + " " + bbcodeToHtml(m.text || "");
    div.appendChild(ts); div.appendChild(msg);
  } else if (m._class === "whisper") {
    const who = document.createElement("span"); who.textContent = "[whisper] <" + (m.from || "Anon") + "> ";
    const msg = document.createElement("span"); msg.innerHTML = bbcodeToHtml(m.text || "");
    div.appendChild(ts); div.appendChild(who); div.appendChild(msg);
  } else {
    const nick = document.createElement("span"); nick.textContent = "<" + (m.username || "Anon") + "> ";
    const msg  = document.createElement("span"); msg.innerHTML = bbcodeToHtml(m.text || "");
    div.appendChild(ts); div.appendChild(nick); div.appendChild(msg);
  }

  log.appendChild(div);
  log.scrollTop = log.scrollHeight;
}

    function renderRoster(list){
      const box = $("roster"); box.innerHTML = "";
      for (const u of list) { const d = document.createElement("div"); d.className = "user"; d.textContent = u; box.appendChild(d); }
    }

function onMessage(e){
  let payload; try { payload = JSON.parse(e.data); } catch { return; }

  // History: show past messages, including emotes
  if (payload.type === "history" && Array.isArray(payload.data)) {
    for (let m of payload.data) {
      if (m && m.type === "emote") m = { ...m, _class: "emote" };
      if (!m || ignored.has(m.username)) continue;
      renderMessage(m);
    }
    return;
  }

  // Roster
  if (payload.type === "roster" && Array.isArray(payload.users)) {
    renderRoster(payload.users);
    return;
  }

  // Topic
  if (payload.type === "topic") {
    setTopicUI(payload.topic);
    return;
  }

  // Typing
  if (payload.type === "typing") {
    const t = document.getElementById("typing");
    t.textContent = `${payload.username} is typing…`;
    clearTimeout(typingTimer);
    typingTimer = setTimeout(() => t.textContent = "", 2000);
    return;
  }

  // Whisper (respect ignore + beep setting)
  if (payload.type === "whisper") {
    if (!ignored.has(payload.from)) {
      renderMessage({ ...payload, _class: "whisper" });
      if (beepOn) ding();
    }
    return;
  }

  // Emote
  if (payload.type === "emote") {
    if (!ignored.has(payload.username)) renderMessage({ ...payload, _class: "emote" });
    return;
  }

  // Chat (respect ignore + beep setting)
  if (payload.type === "chat") {
    if (!ignored.has(payload.username)) {
      renderMessage(payload);
      if (payload.username !== nick && beepOn) ding();
    }
    return;
  }

  // Legacy shape (no type)
  if (payload.username && payload.text) {
    if (!ignored.has(payload.username)) renderMessage(payload);
  }
}



    // Start
    connect();

    // ===== Menus: open/close and actions =====
    const menubarEl = document.getElementById("menubar");
    const logEl = document.getElementById("log");
    const rightPane = document.querySelector(".right");
    let openMenu = null;
    let currentZoom = 13;

    menubarEl.addEventListener("click", (e) => {
      const btn = e.target.closest(".menu-btn");
      const item = e.target.closest(".dropdown a");
      if (btn) {
        const id = "menu-" + btn.dataset.menu;
        const menu = document.getElementById(id);
        const rect = btn.getBoundingClientRect();
        const host = menubarEl.getBoundingClientRect();
        menu.style.left = (rect.left - host.left) + "px";
        menu.style.display = (menu.style.display === "block") ? "none" : "block";
        if (openMenu && openMenu !== menu) openMenu.style.display = "none";
        openMenu = menu.style.display === "block" ? menu : null;
      } else if (item) {
        handleAction(item.dataset.action);
        closeMenus();
      }
    });
    document.addEventListener("click", (e) => { if (!menubarEl.contains(e.target)) closeMenus(); });
    function closeMenus(){ document.querySelectorAll(".dropdown").forEach(d=>d.style.display="none"); openMenu=null; }

    function handleAction(a){
      switch(a){
        case "save-log": return saveLog();
        case "print": return window.print();
        case "clear-log": return (logEl.innerHTML = "");
        case "join-room": return joinRoom();
        case "copy-log": return copyLog();
        case "find": return findInLog();
        case "select-all": return selectAllLog();
        case "zoom-in": return zoom(1);
        case "zoom-out": return zoom(-1);
        case "toggle-timestamps": return logEl.classList.toggle("hide-ts");
        case "toggle-roster": return rightPane.classList.toggle("hidden");
        case "toggle-beep": beepOn = !beepOn; alert("Beep is " + (beepOn ? "ON" : "OFF")); return;
        case "help": return showHelp();
        case "about": return alert("Web Chat • AOL-era look\nFormatting: [b] [i] [u] [color=red] [size=14] [font=Courier New]");
        case "set-topic": {
  const t = prompt("Set room topic (140 chars max):", document.getElementById("topicText").textContent || "");
  if (t != null) send({ type:"settopic", topic: t.slice(0,140), username:nick });
  return;
}
      }
    }

// Tips bar controls (safe single-definition version)
(() => {
  const TIPS_KEY = "aolchat_tips_hidden";
  const tipsEl = document.getElementById("tips");
  const hideTipsBtn = document.getElementById("hideTips");
  const moreHelpBtn = document.getElementById("moreHelp");

  if (!tipsEl) return; // tips not on this page

  // Respect previous hide choice
  if (localStorage.getItem(TIPS_KEY) === "1") tipsEl.style.display = "none";

  if (hideTipsBtn) {
    hideTipsBtn.addEventListener("click", (e) => {
      e.preventDefault();
      const hidden = tipsEl.style.display !== "none";
      tipsEl.style.display = hidden ? "none" : "";
      if (hidden) localStorage.setItem(TIPS_KEY, "1");
      else localStorage.removeItem(TIPS_KEY);
    });
  }

  if (moreHelpBtn) {
    moreHelpBtn.addEventListener("click", (e) => {
      e.preventDefault();
      showHelp();
    });
  }
})();

    
    // Actions
    function saveLog(){
      const text = Array.from(logEl.children).map(d=>d.textContent).join("\n");
      const blob = new Blob([text], { type:"text/plain" });
      const a = document.createElement("a");
      const stamp = new Date().toISOString().replace(/[:.]/g,"-");
      a.href = URL.createObjectURL(blob);
      a.download = `chat-${ROOM}-${stamp}.txt`;
      document.body.appendChild(a); a.click(); a.remove();
    }
    function joinRoom(){
      const room = prompt("Join room:", ROOM);
      if (room && room !== ROOM) {
        const url = new URL(location.href);
        url.searchParams.set("room", room);
        location.href = url.toString();
      }
    }
    async function copyLog(){
      const text = Array.from(logEl.children).map(d=>d.textContent).join("\n");
      try { await navigator.clipboard.writeText(text); alert("Copied."); } catch { alert("Copy failed."); }
    }
    function selectAllLog(){
      const r = document.createRange(); r.selectNodeContents(logEl);
      const s = getSelection(); s.removeAllRanges(); s.addRange(r);
    }
    function findInLog(){
      const term = prompt("Find:"); if (!term) return;
      const lower = term.toLowerCase();
      logEl.querySelectorAll(".hilite").forEach(x=>x.classList.remove("hilite"));
      for (const div of logEl.children) {
        if (div.textContent.toLowerCase().includes(lower)) { div.classList.add("hilite"); div.scrollIntoView({block:"nearest"}); break; }
      }
    }
    function zoom(delta){ currentZoom = Math.max(10, Math.min(22, currentZoom + delta)); logEl.style.fontSize = currentZoom + "px"; }
    function showHelp(){
      alert(
`Formatting:
  [b]bold[/b]  [i]italic[/i]  [u]underline[/u]
  [color=red]red text[/color]
  [size=14]14px text[/size]
  [font=Courier New]Courier text[/font]

Toolbar inserts these tags for you.`);
    }

    // Beep
    function ding(){
      try {
        const ac = new (window.AudioContext||window.webkitAudioContext)();
        const o = ac.createOscillator(), g = ac.createGain();
        o.type="square"; o.frequency.value=880;
        g.gain.setValueAtTime(0.0001, ac.currentTime);
        g.gain.exponentialRampToValueAtTime(0.2, ac.currentTime+0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, ac.currentTime+0.15);
        o.connect(g); g.connect(ac.destination); o.start(); o.stop(ac.currentTime+0.16);
      } catch {}
    }

    function setTopicUI(t){ document.getElementById("topicText").textContent = t || "(none)"; }
document.getElementById("topicText").addEventListener("dblclick", () => {
  const t = prompt("Set room topic (140 chars max):", document.getElementById("topicText").textContent || "");
  if (t != null) send({ type:"settopic", topic: t.slice(0,140), username:nick });
});

const rosterEl = document.getElementById("roster");
const ctx = document.getElementById("ctx");
let ctxUser = null;

rosterEl.addEventListener("contextmenu", (e) => {
  const item = e.target.closest(".user"); if (!item) return;
  e.preventDefault();
  ctxUser = item.textContent;
  ctx.style.left = e.pageX + "px";
  ctx.style.top  = e.pageY + "px";
  ctx.style.display = "block";
});
document.addEventListener("click", () => ctx.style.display = "none");

document.getElementById("ctx-whisper").onclick = (e) => {
  e.preventDefault();
  if (!ctxUser) return;
  const txt = prompt("Whisper to " + ctxUser + ":");
  if (txt) send({ type:"whisper", username:nick, to: ctxUser, text: txt });
};
document.getElementById("ctx-ignore").onclick = (e) => {
  e.preventDefault();
  if (!ctxUser) return;
  if (ignored.has(ctxUser)) ignored.delete(ctxUser); else ignored.add(ctxUser);
  saveIgnored();
  alert((ignored.has(ctxUser) ? "Ignoring " : "Unignored ") + ctxUser);
};


    
  </script>
  


</body>
</html>
